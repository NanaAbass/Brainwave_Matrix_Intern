<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPaddy</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Lucide Icons for Edit/Delete -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for chat messages */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #cbd5e1;
            border-radius: 10px;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background-color: #64748b;
            border-radius: 10px;
            border: 2px solid #cbd5e1;
        }
        .typing-indicator-dot {
            animation: bounce 1s infinite;
        }
        .typing-indicator-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-indicator-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes bounce {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-4px);
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main container -->
    <div id="app-container" class="bg-white dark:bg-gray-800 rounded-2xl shadow-xl w-full max-w-lg overflow-hidden flex flex-col h-[90vh] md:h-[80vh]">
        
        <!-- Header -->
        <header class="bg-gray-200 dark:bg-gray-700 p-4 flex justify-between items-center shadow-md">
            <h1 class="text-xl font-bold">MyPaddy</h1>
            <div id="auth-status" class="flex items-center space-x-2">
                <span id="user-info" class="text-sm"></span>
                <button id="auth-button" class="bg-red-500 hover:bg-red-600 text-white font-medium py-1 px-3 rounded-xl transition-colors duration-200">
                    Sign In
                </button>
            </div>
        </header>

        <!-- Chat messages container -->
        <main id="chat-messages" class="flex-1 overflow-y-auto p-4 space-y-4 chat-container"></main>
        
        <!-- Typing Indicator -->
        <div id="typing-indicator" class="p-2 text-sm text-gray-600 dark:text-gray-400 bg-gray-100 dark:bg-gray-800 border-t border-gray-300 dark:border-gray-600 hidden">
            <span id="typing-indicator-text"></span>
        </div>

        <!-- Message input form -->
        <form id="message-form" class="p-4 bg-gray-200 dark:bg-gray-700 border-t border-gray-300 dark:border-gray-600">
            <div class="flex space-x-2">
                <input
                    type="text"
                    id="message-input"
                    class="flex-1 p-3 rounded-xl border border-gray-400 dark:border-gray-600 bg-gray-100 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors"
                    placeholder="Type a message..."
                    required
                >
                <button
                    type="submit"
                    id="send-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-xl transition-colors duration-200"
                >
                    Send
                </button>
            </div>
        </form>

        <!-- Auth Modal (Kept for Sign In/Up/Anonymous) -->
        <div id="auth-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white dark:bg-gray-800 rounded-2xl p-8 shadow-2xl max-w-sm w-full">
                <h2 class="text-2xl font-bold mb-6 text-center">Sign In</h2>
                <form id="login-form" class="space-y-4">
                    <input
                        type="email"
                        id="email-input"
                        placeholder="Email"
                        class="w-full p-3 rounded-xl border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                    <input
                        type="password"
                        id="password-input"
                        placeholder="Password"
                        class="w-full p-3 rounded-xl border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    >
                    <!-- NEW: Status/Error Message Placeholder -->
                    <span id="auth-status-message" class="text-sm text-red-500 text-center block h-4"></span>
                    
                    <button
                        type="submit"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 rounded-xl transition-colors duration-200"
                    >
                        Sign In
                    </button>
                </form>
                <div class="text-center mt-4">
                    <p class="text-sm text-gray-600 dark:text-gray-400">
                        Don't have an account? 
                        <a href="#" id="signup-link" class="text-blue-500 hover:underline font-medium">Sign Up</a>
                    </p>
                </div>
                <div class="mt-6 text-center">
                    <button id="anonymous-button" class="w-full bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold py-3 rounded-xl transition-colors duration-200">
                        Sign In Anonymously
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Edit Modal (New) -->
        <div id="edit-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
            <div class="bg-white dark:bg-gray-800 rounded-2xl p-8 shadow-2xl max-w-sm w-full">
                <h2 class="text-xl font-bold mb-4">Edit Message</h2>
                <input
                    type="text"
                    id="edit-input"
                    class="w-full p-3 rounded-xl border border-gray-300 dark:border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 mb-4"
                >
                <div class="flex justify-end space-x-2">
                    <button id="cancel-edit-button" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-xl transition-colors">
                        Cancel
                    </button>
                    <button id="save-edit-button" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-xl transition-colors">
                        Save Changes
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- Firebase SDK Scripts -->
    <script type="module">
        // Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signInAnonymously, signOut, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, serverTimestamp, setLogLevel, deleteDoc, updateDoc, doc, setDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // Configuration and Initialization
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // Check the environment variable. If it's missing or empty (as indicated by the error),
        // we'll attempt to use a placeholder configuration below.
        let firebaseConfig = (typeof __firebase_config !== 'undefined' && __firebase_config.length > 2) 
            ? JSON.parse(__firebase_config) 
            : {}; // Fallback to an empty object if environment variable is unavailable

        
        firebaseConfig = {
            apiKey: ["INSERT YOUR apiKEY"],
            authDomain: "paddieschat-project-fb8af.firebaseapp.com",
            projectId: "paddieschat-project-fb8af",
            storageBucket: "paddieschat-project-fb8af.firebasestorage.app",
            messagingSenderId: ["INSERT ID HERE"],
            appId: ["APPid HERE"],
            measurementId: ["INSERT ID HERE"]
        };
        
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        setLogLevel('debug');
        
        // --- DOM Elements ---
        const authButtonEl = document.getElementById('auth-button');
        const userInfoEl = document.getElementById('user-info');
        const chatMessagesEl = document.getElementById('chat-messages');
        const messageFormEl = document.getElementById('message-form');
        const messageInputEl = document.getElementById('message-input');
        const authModalEl = document.getElementById('auth-modal');
        const loginFormEl = document.getElementById('login-form');
        const emailInputEl = document.getElementById('email-input');
        const passwordInputEl = document.getElementById('password-input');
        const anonymousButtonEl = document.getElementById('anonymous-button');
        const signupLinkEl = document.getElementById('signup-link');
        const editModalEl = document.getElementById('edit-modal');
        const editInputEl = document.getElementById('edit-input');
        const saveEditButtonEl = document.getElementById('save-edit-button');
        const cancelEditButtonEl = document.getElementById('cancel-edit-button');
        const typingIndicatorEl = document.getElementById('typing-indicator');
        const typingIndicatorTextEl = document.getElementById('typing-indicator-text');
        // NEW: Error/Status display
        const authStatusMessageEl = document.getElementById('auth-status-message');

        // --- State and Listeners ---
        let isAuthReady = false;
        let unsubscribeMessageSnapshot = null;
        let unsubscribeTypingSnapshot = null;
        let currentEditingMessageId = null;

        // --- Utility Functions ---
        
        // Helper function to show status/error in the Auth Modal
        const showAuthStatus = (message, isError = true) => {
            authStatusMessageEl.textContent = message;
            authStatusMessageEl.className = `text-sm text-center block h-4 ${isError ? 'text-red-500' : 'text-green-500'}`;
            setTimeout(() => {
                authStatusMessageEl.textContent = '';
            }, 4000);
        };

        // Function to deterministically generate a color based on a string (e.g., UID)
        const stringToColor = (str) => {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            let color = '#';
            for (let i = 0; i < 3; i++) {
                const value = (hash >> (i * 8)) & 0xFF;
                color += ('00' + value.toString(16)).substr(-2);
            }
            return color;
        };

        // Get a default display name
        const getDisplayName = (user) => {
            if (user.email) return user.email.split('@')[0];
            return `User_${user.uid.substring(0, 6)}`;
        };

        // --- Firestore Operations (Edit/Delete) ---

        const deleteMessage = async (docId) => {
            // IMPORTANT: Using a custom modal is MANDATORY in the Canvas environment instead of native confirm/alert.
            const userConfirmed = await new Promise(resolve => {
                const modalHtml = `
                    <div id="custom-confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 backdrop-blur-sm flex items-center justify-center p-4 z-[99]">
                        <div class="bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-2xl max-w-xs w-full">
                            <h3 class="text-lg font-bold mb-4">Confirm Deletion</h3>
                            <p class="mb-6 text-sm text-gray-700 dark:text-gray-300">Are you sure you want to delete this message?</p>
                            <div class="flex justify-end space-x-2">
                                <button id="confirm-cancel" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded-xl transition-colors text-sm">Cancel</button>
                                <button id="confirm-delete" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-xl transition-colors text-sm">Delete</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHtml);

                const modal = document.getElementById('custom-confirm-modal');
                document.getElementById('confirm-delete').onclick = () => { modal.remove(); resolve(true); };
                document.getElementById('confirm-cancel').onclick = () => { modal.remove(); resolve(false); };
            });

            if (!userConfirmed) return;

            try {
                const messageDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'messages', docId);
                await deleteDoc(messageDocRef);
                console.log('Message deleted:', docId);
            } catch (error) {
                console.error('Error deleting message:', error);
                // Custom alert replacement for unexpected delete error
            }
        };

        const updateMessageText = async (docId, newText) => {
            try {
                const messageDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'messages', docId);
                await updateDoc(messageDocRef, {
                    text: newText,
                    edited: true,
                    editedAt: serverTimestamp()
                });
                editModalEl.classList.add('hidden');
                console.log('Message updated:', docId);
            } catch (error) {
                console.error('Error updating message:', error);
                // Custom alert replacement for unexpected update error
            }
        };

        // --- UI Functions ---

        const showEditModal = (docId, currentText) => {
            currentEditingMessageId = docId;
            editInputEl.value = currentText;
            editModalEl.classList.remove('hidden');
            editInputEl.focus();
        };
        
        cancelEditButtonEl.addEventListener('click', () => {
            editModalEl.classList.add('hidden');
            currentEditingMessageId = null;
        });

        saveEditButtonEl.addEventListener('click', () => {
            const newText = editInputEl.value.trim();
            if (currentEditingMessageId && newText) {
                updateMessageText(currentEditingMessageId, newText);
            }
        });

        const createMessageElement = (message, docId, currentUserUid) => {
            const isCurrentUser = message.userId === currentUserUid;
            const displayName = getDisplayName({ uid: message.userId, email: message.userEmail });
            const avatarColor = stringToColor(message.userId);

            const messageEl = document.createElement('div');
            messageEl.className = `flex ${isCurrentUser ? 'justify-end' : 'justify-start'}`;
            messageEl.dataset.docId = docId;
            
            // Avatar (only show for others)
            const avatarEl = document.createElement('div');
            if (!isCurrentUser) {
                avatarEl.className = 'w-8 h-8 rounded-full flex items-center justify-center text-white font-bold text-xs mr-2 flex-shrink-0 self-start';
                avatarEl.style.backgroundColor = avatarColor;
                avatarEl.textContent = displayName.charAt(0).toUpperCase();
            }

            const messageContentWrapper = document.createElement('div');
            messageContentWrapper.className = `flex flex-col max-w-xs md:max-w-md ${isCurrentUser ? 'items-end' : 'items-start'}`;

            const messageContentEl = document.createElement('div');
            messageContentEl.className = `p-3 rounded-xl shadow-md ${
                isCurrentUser
                    ? 'bg-blue-600 text-white rounded-br-none flex flex-row-reverse space-x-2 space-x-reverse'
                    : 'bg-gray-300 dark:bg-gray-700 text-gray-900 dark:text-gray-100 rounded-bl-none flex flex-row space-x-2'
            } group relative`;
            
            // Text container
            const textContainer = document.createElement('div');
            textContainer.className = 'flex flex-col';

            const userTextEl = document.createElement('div');
            userTextEl.className = `font-bold text-xs mb-1 ${isCurrentUser ? 'text-white/80' : 'text-gray-700 dark:text-gray-300'}`;
            userTextEl.textContent = displayName;

            const textEl = document.createElement('p');
            textEl.className = 'text-sm break-words whitespace-pre-wrap';
            textEl.textContent = message.text;

            textContainer.appendChild(userTextEl);
            textContainer.appendChild(textEl);
            
            // Edit/Delete buttons (only for current user)
            if (isCurrentUser) {
                const actionContainer = document.createElement('div');
                actionContainer.className = 'flex flex-col justify-center opacity-0 group-hover:opacity-100 transition-opacity space-y-1 ml-2';
                
                const editButton = document.createElement('button');
                editButton.className = 'text-white/70 hover:text-white transition-colors p-1 rounded-full';
                editButton.innerHTML = lucide.createIcons()['pencil'].toSvg({ width: 14, height: 14 });
                editButton.onclick = () => showEditModal(docId, message.text);

                const deleteButton = document.createElement('button');
                deleteButton.className = 'text-white/70 hover:text-red-300 transition-colors p-1 rounded-full';
                deleteButton.innerHTML = lucide.createIcons()['trash-2'].toSvg({ width: 14, height: 14 });
                deleteButton.onclick = () => deleteMessage(docId);
                
                actionContainer.appendChild(editButton);
                actionContainer.appendChild(deleteButton);

                messageContentEl.appendChild(actionContainer);
            }

            messageContentEl.appendChild(textContainer);

            const timeEl = document.createElement('span');
            timeEl.className = `block text-xs text-right mt-1 opacity-70 ${isCurrentUser ? 'text-white/70' : 'text-gray-600 dark:text-gray-400'}`;
            const date = message.createdAt?.toDate ? message.createdAt.toDate() : new Date();
            let timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            if (message.edited) {
                timeString += ' (edited)';
            }
            timeEl.textContent = timeString;

            messageContentWrapper.appendChild(messageContentEl);
            messageContentWrapper.appendChild(timeEl);
            
            if (!isCurrentUser) {
                messageEl.appendChild(avatarEl);
            }
            messageEl.appendChild(messageContentWrapper);

            return messageEl;
        };

        // --- Real-Time Listeners (Typing Indicator) ---

        const setupTypingListener = (currentUserUid) => {
            if (unsubscribeTypingSnapshot) {
                unsubscribeTypingSnapshot();
            }

            const typingDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'typing', 'status');

            unsubscribeTypingSnapshot = onSnapshot(typingDocRef, (docSnap) => {
                if (!docSnap.exists()) return;

                const typingStatus = docSnap.data().users || {};
                const now = Date.now();
                const activeTypers = [];

                for (const uid in typingStatus) {
                    // Consider a user active if they typed in the last 4 seconds
                    if (uid !== currentUserUid && (now - typingStatus[uid].lastTyped) < 4000) {
                        activeTypers.push(typingStatus[uid].name);
                    }
                }

                if (activeTypers.length > 0) {
                    const names = activeTypers.join(', ');
                    typingIndicatorTextEl.innerHTML = `${names} ${activeTypers.length > 1 ? 'are' : 'is'} typing<span class="typing-indicator-dot">.</span><span class="typing-indicator-dot">.</span><span class="typing-indicator-dot">.</span>`;
                    typingIndicatorEl.classList.remove('hidden');
                } else {
                    typingIndicatorEl.classList.add('hidden');
                }
            }, (error) => console.error("Typing status listener error:", error));
        };

        let typingTimeout = null;
        const updateTypingStatus = (user, isTyping) => {
            const typingDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'typing', 'status');
            const userRef = `users.${user.uid}`;
            const displayName = getDisplayName(user);
            
            const data = isTyping ? { [userRef]: { lastTyped: Date.now(), name: displayName } } : { [userRef]: null };

            // Use updateDoc for removing the user, or setDoc with merge for adding/updating
            updateDoc(typingDocRef, data).catch(err => {
                // If document doesn't exist (first typer), use setDoc to create it
                if (err.code === 'not-found') {
                    setDoc(typingDocRef, { users: { [user.uid]: { lastTyped: Date.now(), name: displayName } } })
                        .catch(console.error);
                } else {
                    console.error("Error updating typing status:", err);
                }
            });
        };

        messageInputEl.addEventListener('input', (e) => {
            const user = auth.currentUser;
            if (!user) return;

            // 1. Update status to typing immediately
            updateTypingStatus(user, true);

            // 2. Clear any previous timeout
            clearTimeout(typingTimeout);

            // 3. Set a new timeout to mark user as non-typing after 3 seconds of inactivity
            typingTimeout = setTimeout(() => {
                updateTypingStatus(user, false);
            }, 3000);
        });

        // --- Real-Time Listeners (Messages) ---

        const setupMessageListener = (user) => {
            if (unsubscribeMessageSnapshot) {
                unsubscribeMessageSnapshot();
            }
            
            const q = collection(db, 'artifacts', appId, 'public', 'data', 'messages');

            unsubscribeMessageSnapshot = onSnapshot(q, (snapshot) => {
                // Removed: if (!isAuthReady) return; // This guard prevented the initial message display

                const allMessages = [];
                snapshot.docs.forEach(doc => {
                    // Include the document ID for edit/delete operations
                    allMessages.push({ id: doc.id, ...doc.data() }); 
                });

                allMessages.sort((a, b) => {
                    const timeA = a.createdAt?.toMillis() || 0;
                    const timeB = b.createdAt?.toMillis() || 0;
                    return timeA - timeB;
                });

                // Clear the DOM and redraw all sorted messages
                chatMessagesEl.innerHTML = ''; 
                allMessages.forEach(message => {
                    const messageEl = createMessageElement(message, message.id, user.uid);
                    chatMessagesEl.appendChild(messageEl);
                });
                
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            }, (error) => {
                // IMPORTANT: Log permission errors here, which usually means rules are wrong
                console.error("Firestore messages snapshot error (Check Security Rules!):", error);
            });
        };

        // --- Event Handlers ---

        messageFormEl.addEventListener('submit', async (e) => {
            e.preventDefault();
            const text = messageInputEl.value.trim();
            const user = auth.currentUser;

            if (text && user) {
                // Clear typing status immediately upon sending
                clearTimeout(typingTimeout);
                updateTypingStatus(user, false); 
                
                try {
                    const userId = user.uid;
                    const userEmail = user.email || 'anonymous';
                    const messagesRef = collection(db, 'artifacts', appId, 'public', 'data', 'messages');

                    await addDoc(messagesRef, {
                        text: text,
                        createdAt: serverTimestamp(),
                        userId: userId,
                        userEmail: userEmail,
                        edited: false,
                    });
                    messageInputEl.value = '';
                } catch (error) {
                    console.error('Error adding document: ', error);
                }
            }
        });

        onAuthStateChanged(auth, (user) => {
            if (user) {
                const displayName = getDisplayName(user);
                userInfoEl.textContent = `Hello, ${displayName.substring(0, 10)}... | ID: ${user.uid.substring(0, 6)}...`;
                authButtonEl.textContent = 'Sign Out';
                authModalEl.classList.add('hidden');
                messageFormEl.style.display = 'block';
                isAuthReady = true;

                // Start listeners for messages and typing status
                setupMessageListener(user);
                setupTypingListener(user.uid); 

            } else {
                userInfoEl.textContent = 'Guest';
                authButtonEl.textContent = 'Sign In';
                messageFormEl.style.display = 'none';
                chatMessagesEl.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400">Please sign in to start chatting.</p>';
                isAuthReady = false;
                
                // Stop listeners when user signs out
                if (unsubscribeMessageSnapshot) unsubscribeMessageSnapshot();
                if (unsubscribeTypingSnapshot) unsubscribeMessageSnapshot();
                typingIndicatorEl.classList.add('hidden'); // Hide typing indicator
            }
        });

        // Auth Modal Handlers
        authButtonEl.addEventListener('click', () => {
            if (auth.currentUser) { 
                signOut(auth).catch((error) => console.error('Sign out error:', error)); 
            } 
            else { 
                authModalEl.classList.remove('hidden'); 
                authStatusMessageEl.textContent = ''; // Clear status when opening
            }
        });
        
        loginFormEl.addEventListener('submit', async (e) => { 
            e.preventDefault(); 
            authStatusMessageEl.textContent = 'Signing in...';
            try { 
                await signInWithEmailAndPassword(auth, emailInputEl.value, passwordInputEl.value); 
                authModalEl.classList.add('hidden'); 
            } catch (error) { 
                console.error('Login error:', error); 
                showAuthStatus('Login failed. Check email and password.'); 
            } 
        });
        
        signupLinkEl.addEventListener('click', async (e) => { 
            e.preventDefault(); 
            if (emailInputEl.value && passwordInputEl.value) { 
                authStatusMessageEl.textContent = 'Creating account...';
                try { 
                    await createUserWithEmailAndPassword(auth, emailInputEl.value, passwordInputEl.value); 
                    authModalEl.classList.add('hidden'); 
                } catch (error) { 
                    console.error('Sign up error:', error); 
                    showAuthStatus('Sign up failed. Try a different email.');
                } 
            } else { 
                showAuthStatus('Please enter an email and password to sign up.');
            } 
        });
        
        anonymousButtonEl.addEventListener('click', async () => { 
            authStatusMessageEl.textContent = 'Signing in anonymously...';
            try { 
                await signInAnonymously(auth); 
                authModalEl.classList.add('hidden'); 
            } catch (error) { 
                console.error('Anonymous sign-in error:', error); 
                showAuthStatus('Anonymous sign-in failed. Please try again.');
            } 
        });

        // Initial sign-in attempt upon loading
        // We bypass the custom token since a manual firebaseConfig is provided, 
        // which would otherwise cause an 'auth/custom-token-mismatch' error.
        signInAnonymously(auth).catch((error) => {
            console.error("Initial anonymous sign-in failed:", error);
        });
        
        // Initialize Lucide Icons
        lucide.createIcons();
    </script>
</body>
</html>

